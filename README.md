# compiler
implementation of a cool compiler using java (lexer analyzer , parser )
Lexical Analyzer:
Goal:
tokens for Cool in an appropriate input format and the analyzer generator will generate the tokens.
Specifications:
1) A program that takes a single command-line argument (e.g., file.cl). That argument will be an ASCII text Cool source file. Your program must either indicate that there is an error in the input (e.g., a malformed string) or emit file.cl-lex, a serialized list of Cool tokens.
If your program is called lexer, invoking lexer file.cl should yield the same output as cool --lex file.cl

Error reporting:
To report an error, write the string ERROR: line_number: Lexer: message to standard output and terminate the program. You may write whatever you want in the message, but it should be fairly indicative. Example erroneous input:
Backslash not allowed \

The .cl-lex File Format:
If there are no errors in file.cl your program should create file.cl-lex and serialize the tokens to it. Each token is represented by a pair (or triplet) of lines. The first line holds the line number. The second line gives the name of the token. The optional third line holds additional information (i.e., the lexeme) for identifiers, integers, strings and types. For example, for an integer token the third line should contain the decimal integer value
The Parser:
Goal:
For this assignment, you will write a parser using a parser generator.
You will also write additional code to unserialize the tokens produced by the lexer stage and to serialize the Concrete Syntax Tree (CST) produced by your parser.

The Specification:
1) A program that takes a single command-line argument (e.g., file.cl-lex). That argument will be an ASCII text Cool tokens file (as described in the lexer programming assignment). The cl-lex file will always be well-formed (i.e., there will be no syntax errors in the cl-lex file itself).
If your program is called parser, invoking parser file.cl-lex should yield the same output as cool --parse file.cl.
Your program can take another argument which is the file to print the output of the Concrete Syntax Tree (CST) as follows: parser file.cl-lex file.cl-cst
Your program should determine and print any errors in the parsing tree and terminate the program.
2)Test cases good.cl and bad.cl. The first should parse correctly and yield an abstract syntax tree. The second should contain an error.
3) A plain ASCII text file called readme.txt describing your design decisions and choice of test cases. A few paragraphs should suffice.

3-Three address code:

the final output of the project is to generate the three address code of the input COOL program.
We use the parsing tree to generate 3 address code by using the visitor file that is generated by the parser
Then we implement the functions according to the parser rules and three address code rules.  
